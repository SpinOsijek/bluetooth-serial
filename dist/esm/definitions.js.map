{"version":3,"file":"definitions.js","sourceRoot":"","sources":["../../src/definitions.ts"],"names":[],"mappings":"AAqHA,MAAM,CAAN,IAAY,eAEX;AAFD,WAAY,eAAe;IACzB,qDAAI,CAAA;IAAE,iEAAU,CAAA;IAAE,+DAAS,CAAA;AAC7B,CAAC,EAFW,eAAe,KAAf,eAAe,QAE1B","sourcesContent":["import type { PermissionState, PluginListenerHandle } from \"@capacitor/core\";\r\n\r\nexport interface BluetoothSerialPlugin {\r\n  echo(options: { value: string }): Promise<{ value: string }>;\r\n  /**\r\n   * Creates a secure connection (https://developer.android.com/reference/android/bluetooth/BluetoothDevice#createRfcommSocketToServiceRecord(java.util.UUID)) to the bluetooth device with the given address.\r\n   * The plugin only retains one connection at a time; upon connecting to a device, while there is already an existing connection,\r\n   * the previous device is disconnected. If there is already a running connect call that hasn't resolved, and a new one starts, the original will reject with \"Connection interrupted\".\r\n   * Requires CONNECT permission on Android API >= 30\r\n   */\r\n  connect(options: connectionOptions): Promise<void>;\r\n  /**\r\n   * Creates an insecure connection (https://developer.android.com/reference/android/bluetooth/BluetoothDevice#createInsecureRfcommSocketToServiceRecord(java.util.UUID)) to the bluetooth device with the given address.\r\n   * The plugin only retains one connection at a time; upon connecting to a device, while there is already an existing connection,\r\n   * the previous device is disconnected. If there is already a running connect call that hasn't resolved, and a new one starts, the original will reject with \"Connection interrupted\".\r\n   * Requires CONNECT permission on Android API >= 30\r\n   */\r\n  connectInsecure(options: connectionOptions): Promise<void>;\r\n  /**\r\n   * Disconnects from the currently connected device.\r\n   * This may be called while there is no connected device; in that case, the method will resolve with void.\r\n   */\r\n  disconnect(): Promise<void>;\r\n  /**\r\n   * Returns data emitted from the currently connected device.\r\n   */\r\n  read(): Promise<{ data: string }>;\r\n  /**\r\n   * Writes data to the currently connected device.\r\n   */\r\n  write(options: { data: string }): Promise<void>;\r\n  /**\r\n   * Returns the length of the data that can be read by calling read().\r\n   */\r\n  available(): Promise<{ available: number }>;\r\n  /**\r\n   * Returns true or false depending on whether bluetooth is enabled.\r\n   */\r\n  isEnabled(): Promise<{ isEnabled: boolean }>;\r\n  /**\r\n   * Returns true or false depending on whether the plugin is currently connected to a device.\r\n   */\r\n  isConnected(): Promise<{ isConnected: boolean }>;\r\n  /**\r\n   * Clears the data readable by calling read().\r\n   */\r\n  clear(): Promise<void>;\r\n  /**\r\n   * Displays the native prompt for enabling bluetooth. Returns true or false depending on whether the user enabled bluetooth.\r\n   * Requires CONNECT permission on Android API >= 30\r\n   */\r\n  enable(): Promise<{ isEnabled: boolean }>;\r\n  /**\r\n   * Opens the native bluetooth settings activity. Resolves immediately upon being called.\r\n   */\r\n  settings(): Promise<void>;\r\n  /**\r\n   * Returns a list of bonded devices. This includes devices that were previously paired with the user's device\r\n   * Requires CONNECT permission on Android API >= 30\r\n   */\r\n  list(): Promise<devices>;\r\n  /**\r\n   * Begins the discovery of nearby devices and resolves with them once discovery is finished.\r\n   * There may only be one discovery process at a time. If another call starts while there is a discovery in progress,\r\n   * the original call will resolve with \"Discovery cancelled\".\r\n   * \r\n   * On Android API >= 30 requires SCAN, CONNECT and FINE_LOCATION permissions.\r\n   * You can declare in your manifest that scanning for devices is not used to derive the user's location. In that case, you may also\r\n   * add the following into your capacitor.config.ts to indicate that the plugin should not require FINE_LOCATION:\r\n   * \r\n   * BluetoothSerial: {\r\n   *  neverScanForLocation: true,\r\n   * }\r\n   * \r\n   * In that case, only SCAN and CONNECT are required.\r\n   * \r\n   * On Android 10 and 11, only FINE_LOCATION is required.\r\n   * \r\n   * On lower versions, only COARSE_LOCATION is required.\r\n   * \r\n   * The versions of Android that require location permissions, also require location services to be enabled.\r\n   * So this plugin will reject with \"Location services not enabled\" if the device requires location for scanning, but it is disabled.\r\n   * \r\n   * https://developer.android.com/guide/topics/connectivity/bluetooth/permissions\r\n   */\r\n  discoverUnpaired(): Promise<devices>;\r\n  /**\r\n   * Cancels current unpaired devices discovery, if there is one in progress. If there is no discovery in progress, resolves with void.\r\n   * Be sure to note that calling this will reject any existing discoverUnpaired() call which hasn't resolved yet.\r\n   * Requires SCAN permission on Android API >= 30\r\n   */\r\n  cancelDiscovery(): Promise<void>;\r\n  /**\r\n   * Takes into account the fact that SCAN and CONNECT permissions only exist on Android 11+; those permissions will always resolve as GRANTED\r\n   * on devices below Android 11.\r\n   */\r\n  checkPermissions(): Promise<PermissionStatus[]>;\r\n  /**\r\n   * Takes into account the fact that SCAN and CONNECT permissions only exist on Android 11+; those permissions will always resolve as GRANTED\r\n   * on devices below Android 11.\r\n   */\r\n  requestPermissions(options: { permissions: permissions[] }): Promise<PermissionStatus[]>;\r\n  addListener(event: 'discoverUnpaired', listenerFunc: (event: devices) => any): Promise<PluginListenerHandle> & PluginListenerHandle;\r\n  addListener(event: 'connectionChange', listenerFunc: (event: { state: ConnectionState }) => any): Promise<PluginListenerHandle> & PluginListenerHandle;\r\n  removeAllListeners(): Promise<void>;\r\n}\r\n\r\nexport interface BluetoothDevice {\r\n  address: string;\r\n  name?: string;\r\n  // you may use this property to conclude what sort of device the connected device is\r\n  deviceClass?: number;\r\n}\r\n\r\nexport type permissions = 'coarseLocation' | 'fineLocation' | 'scan' | 'connect';\r\nexport type PermissionStatus = { [permission in permissions]?: PermissionState };\r\nexport type devices = { devices: BluetoothDevice[] };\r\nexport enum ConnectionState {\r\n  NONE, CONNECTING, CONNECTED,\r\n}\r\ntype connectionOptions = { address: string };"]}